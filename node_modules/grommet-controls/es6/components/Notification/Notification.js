var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { compose } from 'recompose';
import { Box, Text, Button, Heading, Meter } from 'grommet';
import { withTheme } from 'grommet/components/hocs';
import { deepMerge } from 'grommet/utils/object';
import { Close, StatusGood, StatusWarning, StatusCritical, StatusUnknown, StatusInfo, StatusDisabled } from 'grommet-icons';
import { longDate } from '../../utils/moment';

import doc from './doc';

var StatusIcons = {
  ok: StatusGood,
  warning: StatusWarning,
  error: StatusCritical,
  unknown: StatusUnknown,
  disabled: StatusDisabled,
  info: StatusInfo
};

var SIZE_LEVELS = {
  small: {
    level: 4,
    size: 'xsmall',
    meterSize: 'xsmall'
  },
  medium: {
    level: 3,
    size: 'small',
    meterSize: 'small'
  },
  large: {
    level: 1,
    size: 'medium',
    meterSize: 'large'
  }
};

var Notification = function (_Component) {
  _inherits(Notification, _Component);

  function Notification() {
    _classCallCheck(this, Notification);

    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  Notification.prototype.render = function render() {
    var _props = this.props,
        status = _props.status,
        message = _props.message,
        locale = _props.locale,
        closer = _props.closer,
        margin = _props.margin,
        reverse = _props.reverse,
        a11yTitle = _props.a11yTitle,
        background = _props.background,
        border = _props.border,
        timestamp = _props.timestamp,
        theme = _props.theme,
        icon = _props.icon,
        strong = _props.strong,
        round = _props.round,
        pad = _props.pad,
        size = _props.size,
        state = _props.state,
        onClose = _props.onClose,
        percentComplete = _props.percentComplete,
        rest = _objectWithoutProperties(_props, ['status', 'message', 'locale', 'closer', 'margin', 'reverse', 'a11yTitle', 'background', 'border', 'timestamp', 'theme', 'icon', 'strong', 'round', 'pad', 'size', 'state', 'onClose', 'percentComplete']);

    var sizeLevel = SIZE_LEVELS[size];
    var grommet = this.context.grommet;

    var Border = deepMerge(theme.notification ? theme.notification.border : {}, border);
    var Round = round || (theme.notification && theme.notification.border ? theme.notification.border.round : undefined);
    var closeBtn = void 0;
    if (onClose) {
      var closeIcon = closer || React.createElement(Close, { size: sizeLevel.size });
      closeBtn = React.createElement(
        Box,
        { pad: pad },
        React.createElement(
          Button,
          {
            a11yTitle: a11yTitle,
            onClick: onClose || function () {}
          },
          closeIcon
        )
      );
    }
    var heading = message;
    if (strong) {
      heading = React.createElement(
        'strong',
        null,
        heading
      );
    }
    var statusIcon = void 0;
    if (icon) {
      var StatusIcon = StatusIcons[status];
      statusIcon = React.isValidElement(icon) ? icon : React.createElement(StatusIcon, { size: sizeLevel.size });
    }
    var progress = void 0;
    if (percentComplete || percentComplete === 0) {
      progress = React.createElement(
        Box,
        { direction: 'row', align: 'center', pad: { between: 'medium' }, style: { whiteSpace: 'nowrap' } },
        React.createElement(Meter, {
          size: sizeLevel.meterSize,
          thickness: 'small',
          values: [{
            label: percentComplete,
            value: percentComplete,
            color: 'accent-1'
          }]
        }),
        React.createElement(
          Text,
          { size: 'small' },
          ' ' + percentComplete + ' %'
        )
      );
    }
    var timeStamp = void 0;
    if (timestamp) {
      timeStamp = longDate(timestamp, locale);
    }
    return React.createElement(
      Box,
      _extends({
        direction: reverse ? 'row-reverse' : 'row',
        fill: 'horizontal',
        border: Border,
        round: Round,
        onClick: this.clickTag,
        role: 'checkbox',
        'aria-checked': true,
        background: background || 'status-' + status,
        reverse: reverse,
        theme: theme,
        grommet: grommet
      }, rest),
      React.createElement(
        Box,
        { flex: 'grow', pad: pad },
        React.createElement(
          Heading,
          { level: sizeLevel.level, margin: margin, style: { maxWidth: '100%' } },
          React.createElement(
            Box,
            { direction: reverse ? 'row-reverse' : 'row', align: 'center', gap: 'small' },
            statusIcon,
            heading
          )
        ),
        React.createElement(
          Text,
          { size: sizeLevel.size },
          state
        ),
        React.createElement(
          Text,
          { size: sizeLevel.size },
          timeStamp
        ),
        progress
      ),
      closeBtn
    );
  };

  return Notification;
}(Component);

Notification.contextTypes = {
  grommet: PropTypes.object
};
Notification.defaultProps = {
  status: 'info',
  size: 'medium',
  message: 'Notification...',
  icon: true,
  animation: 'fadeIn',
  closer: undefined,
  pad: 'small',
  margin: 'small',
  locale: 'en-us'
};


if (process.env.NODE_ENV !== 'production') {
  doc(Notification);
}

export default compose(withTheme)(Notification);